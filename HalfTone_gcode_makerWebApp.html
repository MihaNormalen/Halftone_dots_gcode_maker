<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DotsSVG Master - Professional UI</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --accent-color: #00adb5;
            --text-color: #e0e0e0;
            --input-bg: #2b2b2b;
            --border-color: #333;
        }

        body {
            font-family: 'Inter', system-ui, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        #sidebar {
            width: 380px;
            background-color: var(--panel-color);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
        }

        h2 { color: var(--accent-color); font-size: 1rem; text-transform: uppercase; letter-spacing: 1px; margin: 15px 0 5px 0; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        .group { display: flex; flex-direction: column; gap: 5px; }
        label { font-size: 0.75rem; color: #888; text-transform: uppercase; }
        
        input, select {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .btn-container { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
        }
        button:hover { filter: brightness(1.2); }
        .secondary-btn { background-color: #444; }

        /* Main Viewport */
        #viewport {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 15px;
            background: radial-gradient(circle at center, #1a1a1a 0%, #121212 100%);
        }

        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            background: #000;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        canvas { width: 100%; height: 100%; image-rendering: pixelated; }

        #terminal {
            height: 180px;
            background: #080808;
            border: 1px solid #222;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Fira Code', monospace;
            font-size: 0.75rem;
            color: #4caf50;
            overflow-y: scroll;
            white-space: pre;
        }

        .stats { font-size: 0.8rem; color: #00adb5; margin-bottom: 5px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2 style="margin-top:0">üìÅ Halftone Input</h2>
    <div class="group">
        <label>SVG File</label>
        <input type="file" id="fileInput" accept=".svg">
    </div>

    <h2>üé® Painting Logic</h2>
    <div class="group">
        <label>Infill Method</label>
        <select id="fillType">
            <option value="spiral">Halftone Spiral (Fluid)</option>
            <option value="concentric">Concentric Rings (Classic)</option>
        </select>
    </div>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <div class="group"><label>Brush (mm)</label><input type="number" id="brushWidth" value="2.0" step="0.1"></div>
        <div class="group"><label>Overlap</label><input type="number" id="overlap" value="0.8" step="0.05"></div>
    </div>
    <div class="group">
        <label>Target Width (mm)</label>
        <input type="number" id="targetWidth" value="200">
    </div>

    <h2>üõ¢Ô∏è Dipping & Safety</h2>
    <div class="group">
        <label>Max Path Length (mm)</label>
        <input type="number" id="maxDist" value="1000">
    </div>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 10px;">
        <div class="group"><label>X Offset</label><input type="number" id="xOffset" value="33"></div>
        <div class="group"><label>Y Offset</label><input type="number" id="yOffset" value="110"></div>
        <div class="group"><label>Dip X</label><input type="number" id="dipX" value="91"></div>
        <div class="group"><label>Dip Y</label><input type="number" id="dipY" value="25"></div>
        <div class="group"><label>Dip Z (Deep)</label><input type="number" id="dipZ" value="1.3"></div>
        <div class="group"><label>Travel Z (High)</label><input type="number" id="zSafeDip" value="16.0"></div>
        <div class="group"><label>Paint Z (Safe)</label><input type="number" id="zSafe" value="5.0"></div>
        <div class="group"><label>Feed Rate</label><input type="number" id="feedRate" value="1500"></div>
    </div>

    <div class="btn-container">
        <button id="generateBtn">PROCESS</button>
        <button id="downloadBtn" class="secondary-btn">SAVE GCODE</button>
    </div>
    <div id="status" class="stats">Ready...</div>
</div>

<div id="viewport">
    <div id="canvas-wrapper">
        <canvas id="previewCanvas"></canvas>
    </div>
    <div id="terminal">G-code Terminal Output...</div>
</div>

<script>
    let rawCircles = [];
    let processedPaths = []; // To store lines for drawing
    let generatedGCode = "";
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');

    // SVG Parsing
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = (event) => {
            const parser = new DOMParser();
            const doc = parser.parseFromString(event.target.result, "image/svg+xml");
            const svgCircles = doc.querySelectorAll('circle');
            rawCircles = Array.from(svgCircles).map(c => ({
                cx: parseFloat(c.getAttribute('cx') || 0),
                cy: parseFloat(c.getAttribute('cy') || 0),
                r: parseFloat(c.getAttribute('r') || 0)
            }));
            document.getElementById('status').innerText = `Loaded ${rawCircles.length} halftone dots.`;
            visualizeDots();
        };
        reader.readAsText(file);
    });

    function visualizeDots() {
        if (!rawCircles.length) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const margin = 50;
        const minX = Math.min(...rawCircles.map(c => c.cx - c.r));
        const maxX = Math.max(...rawCircles.map(c => c.cx + c.r));
        const range = maxX - minX;
        const scale = (canvas.width - margin * 2) / range;

        ctx.strokeStyle = '#333';
        rawCircles.forEach(c => {
            ctx.beginPath();
            ctx.arc((c.cx - minX) * scale + margin, (c.cy - Math.min(...rawCircles.map(dot => dot.cy))) * scale + margin, c.r * scale, 0, Math.PI * 2);
            ctx.stroke();
        });
    }

    document.getElementById('generateBtn').addEventListener('click', generate);

    function generate() {
        if (!rawCircles.length) return alert("Upload SVG first!");
        
        const cfg = {
            fill: document.getElementById('fillType').value,
            brush: parseFloat(document.getElementById('brushWidth').value),
            overlap: parseFloat(document.getElementById('overlap').value),
            targetW: parseFloat(document.getElementById('targetWidth').value),
            maxDist: parseFloat(document.getElementById('maxDist').value),
            feed: document.getElementById('feedRate').value,
            xOff: parseFloat(document.getElementById('xOffset').value),
            yOff: parseFloat(document.getElementById('yOffset').value),
            dipX: parseFloat(document.getElementById('dipX').value),
            dipY: parseFloat(document.getElementById('dipY').value),
            dipZ: parseFloat(document.getElementById('dipZ').value),
            zSafeDip: parseFloat(document.getElementById('zSafeDip').value),
            zSafe: parseFloat(document.getElementById('zSafe').value)
        };

        const step = cfg.brush * (1.0 - cfg.overlap);
        let gcode = ["G90", "G21", "; Halftone Dots Export", `; Brush: ${cfg.brush}mm` ];
        processedPaths = [];
        
        // Setup scaling
        const minX = Math.min(...rawCircles.map(c => c.cx - c.r));
        const maxX = Math.max(...rawCircles.map(c => c.cx + c.r));
        const maxY = Math.max(...rawCircles.map(c => c.cy + c.r));
        const scale = cfg.targetW / (maxX - minX);

        let dots = rawCircles.map(c => ({
            x: (c.cx - minX) * scale + cfg.xOff,
            y: (maxY - c.cy) * scale + cfg.yOff,
            r: c.r * scale
        }));

        let currentPos = { x: cfg.dipX, y: cfg.dipY, z: cfg.zSafeDip };
        let distSinceDip = 0;

        // --- Initial Dip ---
        addDipSequence(gcode, cfg);
        
        while (dots.length > 0) {
            // Nearest Neighbor Optimization
            let bestIdx = 0;
            let minDist = Infinity;
            dots.forEach((d, i) => {
                let dist = Math.hypot(d.x - currentPos.x, d.y - currentPos.y);
                if (dist < minDist) { minDist = dist; bestIdx = i; }
            });
            const dot = dots.splice(bestIdx, 1)[0];

            // Path length estimation
            let dotPathLen = (cfg.fill === 'spiral') ? 
                (Math.PI * Math.pow(dot.r, 2)) / step : 
                (dot.r / step) * 2 * Math.PI * (dot.r / 2);

            // --- Dip Check ---
            if (distSinceDip + dotPathLen > cfg.maxDist) {
                gcode.push(`; Return to Tray (Max Dist)`);
                gcode.push(`G0 Z${cfg.zSafeDip} F1200`); // LIFT TO TRAVEL HEIGHT BEFORE MOVE
                gcode.push(`G0 X${cfg.dipX} Y${cfg.dipY}`);
                addDipSequence(gcode, cfg);
                distSinceDip = 0;
                currentPos = { x: cfg.dipX, y: cfg.dipY, z: cfg.zSafeDip };
            }

            // --- Move to Dot ---
            gcode.push(`; Move to Dot`);
            // Safety: If we just dipped, we are at zSafeDip. 
            // We move to dot location still at zSafeDip height.
            gcode.push(`G0 X${dot.x.toFixed(3)} Y${dot.y.toFixed(3)} Z${cfg.zSafeDip}`);
            
            // Start Painting
            gcode.push(`G0 Z${cfg.zSafe} ; Drop to Paint Height`);
            gcode.push(`G1 Z0 F600 ; Contact`);

            if (cfg.fill === 'spiral') {
                let theta = 1;
                while (true) {
                    let currR = (step * theta) / (2 * Math.PI);
                    if (currR > dot.r) break;
                    let px = dot.x + currR * Math.cos(theta);
                    let py = dot.y + currR * Math.sin(theta);
                    gcode.push(`G1 X${px.toFixed(3)} Y${py.toFixed(3)} F${cfg.feed}`);
                    theta += 0.3;
                }
            } else {
                for (let r = dot.r; r >= 0; r -= step) {
                    gcode.push(`G1 X${(dot.x + r).toFixed(3)} Y${dot.y.toFixed(3)}`);
                    if (r > 0) gcode.push(`G2 X${(dot.x + r).toFixed(3)} Y${dot.y.toFixed(3)} I${(-r).toFixed(3)} J0`);
                }
            }

            gcode.push(`G0 Z${cfg.zSafe} ; Safe Lift`);
            distSinceDip += dotPathLen;
            currentPos = { x: dot.x, y: dot.y, z: cfg.zSafe };
        }

        gcode.push("G0 Z30 ; Final Lift", "M2");
        generatedGCode = gcode.join("\n");
        document.getElementById('terminal').innerText = generatedGCode;
        drawGCodePath(gcode);
    }

    function addDipSequence(gcode, cfg) {
        gcode.push(`; --- Dipping Sequence ---`);
        gcode.push(`G0 X${cfg.dipX} Y${cfg.dipY}`);
        gcode.push(`G1 Z${cfg.dipZ} F800`);
        // Spiral mix
        for(let i=0; i<10; i++) {
            let r = i * 0.4;
            let a = i * 1.5;
            gcode.push(`G1 X${(cfg.dipX + r*Math.cos(a)).toFixed(2)} Y${(cfg.dipY + r*Math.sin(a)).toFixed(2)} F1000`);
        }
        gcode.push(`G1 Z${cfg.zSafeDip} F1200 ; LIFT TO TRAVEL HEIGHT`);
    }

    function drawGCodePath(lines) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.lineWidth = 1;
        let scale = 2.5;
        let offX = 50, offY = 50;

        ctx.beginPath();
        ctx.strokeStyle = '#555'; // Travel color
        
        let curX = 0, curY = 0, isDown = false;

        lines.forEach(line => {
            if (line.startsWith('G0')) {
                let xMatch = line.match(/X([\d.-]+)/);
                let yMatch = line.match(/Y([\d.-]+)/);
                if (xMatch) curX = parseFloat(xMatch[1]);
                if (yMatch) curY = parseFloat(yMatch[1]);
                ctx.moveTo(curX * scale + offX, curY * scale + offY);
            }
            if (line.startsWith('G1')) {
                ctx.strokeStyle = '#00adb5'; // Paint color
                let xMatch = line.match(/X([\d.-]+)/);
                let yMatch = line.match(/Y([\d.-]+)/);
                if (xMatch) curX = parseFloat(xMatch[1]);
                if (yMatch) curY = parseFloat(yMatch[1]);
                ctx.lineTo(curX * scale + offX, curY * scale + offY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(curX * scale + offX, curY * scale + offY);
            }
        });
    }

    document.getElementById('downloadBtn').addEventListener('click', () => {
        const blob = new Blob([generatedGCode], { type: 'text/plain' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = "dots_halftone.gcode";
        link.click();
    });

    // Handle canvas resizing
    window.addEventListener('resize', () => {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
    });
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;
</script>
</body>
</html>
